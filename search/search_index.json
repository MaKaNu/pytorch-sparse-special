{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytorch-sparse-special","text":"<p>A small library which implements special implementations of pytorch sparse matrices.</p>"},{"location":"#usage","title":"Usage","text":"<p>Read the examples section for a brief instruction how to use the various classes provided by this library.</p> <p>The modules section provides deeper instructions to all the methods and functions provided by the library.</p>"},{"location":"#tests","title":"Tests","text":"<p>The test page provides informations about the scenarios of the unit tests. Additional they also portrait the process of development of the scenarios.</p>"},{"location":"examples/","title":"Examples","text":"<p>This Page gives examples and explanations how this library can be used.</p>"},{"location":"examples/#mask-tensor","title":"Mask Tensor","text":"<p>A mask tensor is a mono value index matrix. It describes at which pixels in an image the pixel is assigned to a class index.</p> <p>A mask tensor is an 3D tensor with following dimensions:</p> \\[Shape = [N, H, W]\\] <p>with \\(N\\) as the number of masks, \\(H\\) as the height of the image and \\(W\\) as the width of the image, following the order of the dimensions like Pytorch.</p> <p>As an Example we use this small example of these three 3 by 3 masks. All three masks are displayed overlapping and since in this example only the zeros overlap we are able to see all three of them, with the \\(blue\\) mask on layer 0, the \\(red\\) mask on layer 1 and the \\(orange\\) mask on layer 2.</p> <p></p> <p>with \\(idx_{blue} = 1\\) , \\(idx_{red} = 3\\) and \\(idx_{orange} = 2\\).</p> <p>So the blue pixel in the upper middle has the indices \\(N=0\\), \\(H=0\\), \\(W=1\\) and the \\(value=1\\). This is also the most left entry in the code example below. Each mask in the code example is ordered from left to right blue -&gt; red -&gt; orange.</p> <p>To create a Mask Tensor use the MaskSparseTensor class with an index and a value tensor as additional attributes to the size:</p> <pre><code>import torch\n\nfrom pytorch_sparse_special.special.sparse_mask import MaskSparseTensor\n\nindices = torch.tensor(\n    [\n#      &lt; blue   &gt;  &lt; red    &gt;  &lt; orange&gt;\n      [0, 0, 0, 0, 1, 1, 1, 1, 2],\n      [0, 1, 1, 2, 0, 0, 2, 2, 1],\n      [1, 0, 2, 1, 0, 2, 0, 2, 1],\n    ],\n)\n\nvalues = torch.tensor(\n#  &lt; blue   &gt;  &lt; red    &gt;  &lt; orange&gt;\n  [1, 1, 1, 1, 3, 3, 3, 3, 2]\n)\n\nsize = (3,3,3)\n\ntensor = MaskSparseTensor(indices, values, size)\n</code></pre> <p>indices define the position of the pixel in the tensor. They have to match the 3D space.</p> <p>values define the class index for each pixel. Shape has to match the Number of pixels of indices.</p> <p>For additional information about the methods implemented to the class refer modules section.</p>"},{"location":"modules/","title":"Modules","text":"provides the SparseMasksTensor class. <p>Copyright (C) 2025  MaKaNu</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> provides the metric functions for pytorch_sparse_special. <p>Copyright (C) 2025  MaKaNu</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> provides the utils functions for pytorch_sparse_special. <p>Copyright (C) 2025  MaKaNu</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p> provides the error classes for pytorch_sparse_special. <p>Copyright (C) 2025  MaKaNU</p> <p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program.  If not, see https://www.gnu.org/licenses/.</p>"},{"location":"modules/#pytorch_sparse_special.special.sparse_mask.SparseMasksTensor","title":"<code>SparseMasksTensor</code>","text":"<p>A 3D Sparse Matrix which represents a stack of binary class masks.</p> Source code in <code>src/pytorch_sparse_special/special/sparse_mask.py</code> <pre><code>class SparseMasksTensor:\n    \"\"\"A 3D Sparse Matrix which represents a stack of binary class masks.\"\"\"\n\n    def __init__(self, indices: torch.Tensor, values: torch.Tensor, size: tuple[int]) -&gt; None:\n        \"\"\"initilaize a SparseMaskTensor instance.\n        The actual tensor is a property of the class object.\n        For further information about the class arguments refer:\n        [sparse_coo_tensor](https://pytorch.org/docs/stable/generated/torch.sparse_coo_tensor.html)\n\n        Args:\n            indices (torch.Tensor): [DxP] The coordinates for the values of the Matrix. D equals 3.\n            values (torch.Tensor): [1xP] The values of the masks.\n            size (tuple[int]): Size of the Matrix. Has to be three values. [NxHxW]\n                N = Number of masks\n                H = Height of image\n                W = Width of image\n\n        Raises:\n            SizeValueError: If Size or indices doesn't match 3D.\n        \"\"\"\n        if len(size) != 3 or indices.shape[0] != 3:\n            raise SizeValueError(self)\n        self.sparse_tensor: torch.Tensor = torch.sparse_coo_tensor(indices, values, size, is_coalesced=True)\n        self.n_total: int = size[0]\n\n    def extract_sparse_region(self, bbox: torch.Tensor) -&gt; tuple[torch.Tensor, torch.Tensor]:\n        \"\"\"\n        Extract non-zero elements within a bounding box from a sparse tensor.\n\n        Args:\n            bbox (torch.Tensor): The BBox, which inhouses the pixels\n\n        Returns:\n            tuple[torch.Tensor, torch.Tensor]: filtered indices and values which are inside the bbox.\n        \"\"\"\n\n        x_min, y_min, x_max, y_max = bbox\n        indices = self.sparse_tensor.indices()\n        values = self.sparse_tensor.values()\n\n        # Mask for indices within the bounding box\n        mask_x = (indices[1] &gt;= x_min) &amp; (indices[1] &lt; x_max)\n        mask_y = (indices[2] &gt;= y_min) &amp; (indices[2] &lt; y_max)\n        mask = mask_x &amp; mask_y\n\n        # Extract the relevant indices and values\n        filtered_indices = indices[:, mask]\n        filtered_values = values[mask]\n\n        return filtered_indices, filtered_values\n\n    def _get_full_count(self, indices: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Creates for all masks count of pixels based on indices.\n\n        Args:\n            indices (torch.Tensor): Tensor with indices.\n\n        Returns:\n            torch.Tensor: Tensor of shape [N, 1] with the number of pixels based on indices.\n        \"\"\"\n        # count the values on the N axis\n        unique_index, count = indices[0, :].unique(return_counts=True)\n\n        # Create Tensor with the range of all mask\n        # necessary, if mask not inside bbox and we want to keep the actual shape\n        num_masks = torch.arange(self.n_total)\n\n        # Final variable which has the shape matching all masks\n        full_count = torch.zeros(num_masks.shape, dtype=torch.long)\n\n        # The unique_index correlates with the mask layer index\n        # which enables infusing the count into full_count\n        full_count[unique_index] = count\n        return full_count\n\n    def pixel_per_mask(self) -&gt; torch.Tensor:\n        \"\"\"Count the number of pixels per masks from the sparse matrix.\n\n        Returns:\n            Tensor: Number of unique values on z axis.\n        \"\"\"\n        indices = self.sparse_tensor.indices()\n        return self._get_full_count(indices)\n\n    def pixel_per_mask_inside(self, bbox: torch.Tensor) -&gt; torch.Tensor:\n        \"\"\"Count the number of pixels per mask inside the given bbox from the sparse matrix.\n\n        Args:\n            bbox (Tensor): holds the bbox information (xmin, ymin, xmax, ymax)\n\n        Returns:\n            Tensor: Number of unique values on z axis inside bbox\n        \"\"\"\n        inside_indices, _ = self.extract_sparse_region(bbox)\n        return self._get_full_count(inside_indices)\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.special.sparse_mask.SparseMasksTensor.__init__","title":"<code>__init__(indices, values, size)</code>","text":"<p>initilaize a SparseMaskTensor instance. The actual tensor is a property of the class object. For further information about the class arguments refer: sparse_coo_tensor</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Tensor</code> <p>[DxP] The coordinates for the values of the Matrix. D equals 3.</p> required <code>values</code> <code>Tensor</code> <p>[1xP] The values of the masks.</p> required <code>size</code> <code>tuple[int]</code> <p>Size of the Matrix. Has to be three values. [NxHxW] N = Number of masks H = Height of image W = Width of image</p> required <p>Raises:</p> Type Description <code>SizeValueError</code> <p>If Size or indices doesn't match 3D.</p> Source code in <code>src/pytorch_sparse_special/special/sparse_mask.py</code> <pre><code>def __init__(self, indices: torch.Tensor, values: torch.Tensor, size: tuple[int]) -&gt; None:\n    \"\"\"initilaize a SparseMaskTensor instance.\n    The actual tensor is a property of the class object.\n    For further information about the class arguments refer:\n    [sparse_coo_tensor](https://pytorch.org/docs/stable/generated/torch.sparse_coo_tensor.html)\n\n    Args:\n        indices (torch.Tensor): [DxP] The coordinates for the values of the Matrix. D equals 3.\n        values (torch.Tensor): [1xP] The values of the masks.\n        size (tuple[int]): Size of the Matrix. Has to be three values. [NxHxW]\n            N = Number of masks\n            H = Height of image\n            W = Width of image\n\n    Raises:\n        SizeValueError: If Size or indices doesn't match 3D.\n    \"\"\"\n    if len(size) != 3 or indices.shape[0] != 3:\n        raise SizeValueError(self)\n    self.sparse_tensor: torch.Tensor = torch.sparse_coo_tensor(indices, values, size, is_coalesced=True)\n    self.n_total: int = size[0]\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.special.sparse_mask.SparseMasksTensor.extract_sparse_region","title":"<code>extract_sparse_region(bbox)</code>","text":"<p>Extract non-zero elements within a bounding box from a sparse tensor.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Tensor</code> <p>The BBox, which inhouses the pixels</p> required <p>Returns:</p> Type Description <code>tuple[Tensor, Tensor]</code> <p>tuple[torch.Tensor, torch.Tensor]: filtered indices and values which are inside the bbox.</p> Source code in <code>src/pytorch_sparse_special/special/sparse_mask.py</code> <pre><code>def extract_sparse_region(self, bbox: torch.Tensor) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Extract non-zero elements within a bounding box from a sparse tensor.\n\n    Args:\n        bbox (torch.Tensor): The BBox, which inhouses the pixels\n\n    Returns:\n        tuple[torch.Tensor, torch.Tensor]: filtered indices and values which are inside the bbox.\n    \"\"\"\n\n    x_min, y_min, x_max, y_max = bbox\n    indices = self.sparse_tensor.indices()\n    values = self.sparse_tensor.values()\n\n    # Mask for indices within the bounding box\n    mask_x = (indices[1] &gt;= x_min) &amp; (indices[1] &lt; x_max)\n    mask_y = (indices[2] &gt;= y_min) &amp; (indices[2] &lt; y_max)\n    mask = mask_x &amp; mask_y\n\n    # Extract the relevant indices and values\n    filtered_indices = indices[:, mask]\n    filtered_values = values[mask]\n\n    return filtered_indices, filtered_values\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.special.sparse_mask.SparseMasksTensor.pixel_per_mask","title":"<code>pixel_per_mask()</code>","text":"<p>Count the number of pixels per masks from the sparse matrix.</p> <p>Returns:</p> Name Type Description <code>Tensor</code> <code>Tensor</code> <p>Number of unique values on z axis.</p> Source code in <code>src/pytorch_sparse_special/special/sparse_mask.py</code> <pre><code>def pixel_per_mask(self) -&gt; torch.Tensor:\n    \"\"\"Count the number of pixels per masks from the sparse matrix.\n\n    Returns:\n        Tensor: Number of unique values on z axis.\n    \"\"\"\n    indices = self.sparse_tensor.indices()\n    return self._get_full_count(indices)\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.special.sparse_mask.SparseMasksTensor.pixel_per_mask_inside","title":"<code>pixel_per_mask_inside(bbox)</code>","text":"<p>Count the number of pixels per mask inside the given bbox from the sparse matrix.</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Tensor</code> <p>holds the bbox information (xmin, ymin, xmax, ymax)</p> required <p>Returns:</p> Name Type Description <code>Tensor</code> <code>Tensor</code> <p>Number of unique values on z axis inside bbox</p> Source code in <code>src/pytorch_sparse_special/special/sparse_mask.py</code> <pre><code>def pixel_per_mask_inside(self, bbox: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Count the number of pixels per mask inside the given bbox from the sparse matrix.\n\n    Args:\n        bbox (Tensor): holds the bbox information (xmin, ymin, xmax, ymax)\n\n    Returns:\n        Tensor: Number of unique values on z axis inside bbox\n    \"\"\"\n    inside_indices, _ = self.extract_sparse_region(bbox)\n    return self._get_full_count(inside_indices)\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.metrics.iou_sparse_masks_bbox","title":"<code>iou_sparse_masks_bbox(sparse_masks, bbox)</code>","text":"<p>Calculates the Intersection over Union for SparseMasksTensor and a bbox</p> <p>Parameters:</p> Name Type Description Default <code>sparse_masks</code> <code>SparseMasksTensor</code> <p>Multiple sparse depictions of a class valued. [WxHxN]</p> required <code>bbox</code> <code>Tensor</code> <p>bbox representation in from [xmin, ymin, xmax, ymax].</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: iou of all masks against the bbox</p> Source code in <code>src/pytorch_sparse_special/metrics.py</code> <pre><code>def iou_sparse_masks_bbox(sparse_masks: SparseMasksTensor, bbox: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Calculates the Intersection over Union for SparseMasksTensor and a bbox\n\n    Args:\n        sparse_masks (SparseMasksTensor): Multiple sparse depictions of a class valued. [WxHxN]\n        bbox (torch.Tensor): bbox representation in from [xmin, ymin, xmax, ymax].\n\n    Returns:\n        torch.Tensor: iou of all masks against the bbox\n    \"\"\"\n    iou = sparse_masks.pixel_per_mask_inside(bbox) / (\n        area_of_bbox(bbox) + sparse_masks.pixel_per_mask() - sparse_masks.pixel_per_mask_inside(bbox)\n    )\n    return iou\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.utils.area_of_bbox","title":"<code>area_of_bbox(bbox)</code>","text":"<p>Calculate the area of a given bbox</p> <p>Parameters:</p> Name Type Description Default <code>bbox</code> <code>Tensor</code> <p>bbox in form [xmin, ymin, xmax, ymax]</p> required <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor: Area of bbox.</p> Source code in <code>src/pytorch_sparse_special/utils.py</code> <pre><code>def area_of_bbox(bbox: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Calculate the area of a given bbox\n\n    Args:\n        bbox (torch.Tensor): bbox in form [xmin, ymin, xmax, ymax]\n\n    Returns:\n        torch.Tensor: Area of bbox.\n    \"\"\"\n    xmin, ymin, xmax, ymax = bbox\n    result: torch.Tensor = (xmax - xmin) * (ymax - ymin)\n    return result\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.errors.SizeValueError","title":"<code>SizeValueError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>A SizeValueError extends ValueError.</p> <p>Should be raised if the vize value of an object does not met the criteria.</p> Source code in <code>src/pytorch_sparse_special/errors.py</code> <pre><code>class SizeValueError(ValueError):\n    \"\"\"A SizeValueError extends ValueError.\n\n    Should be raised if the vize value of an object does not met the criteria.\n    \"\"\"\n\n    def __init__(self, obj: Any) -&gt; None:\n        \"\"\"creates instance of SizeValueError\n\n        Args:\n            obj (Any): The object which size value does not met the criteria.\n        \"\"\"\n        super().__init__(f\"{type(obj)} is defined as 3D Matrix. Fix size or indices attribute!\")\n</code></pre>"},{"location":"modules/#pytorch_sparse_special.errors.SizeValueError.__init__","title":"<code>__init__(obj)</code>","text":"<p>creates instance of SizeValueError</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object which size value does not met the criteria.</p> required Source code in <code>src/pytorch_sparse_special/errors.py</code> <pre><code>def __init__(self, obj: Any) -&gt; None:\n    \"\"\"creates instance of SizeValueError\n\n    Args:\n        obj (Any): The object which size value does not met the criteria.\n    \"\"\"\n    super().__init__(f\"{type(obj)} is defined as 3D Matrix. Fix size or indices attribute!\")\n</code></pre>"},{"location":"tests/","title":"Comparison of sparse iou calculation against normal matrices iou calculation","text":"<p>The calculation for sparse is looking like the following:</p> <ol> <li>determine the indices of the sparse which are located inside the bbox.</li> <li>calculate area of the bbox.</li> <li>Intersection is equal to the sum of mask pixels inside.</li> <li>Union is equal the sum of all mask pixels plus area of bbox minus Intersection.</li> </ol> <p>Formulas</p> \\[area_{bbox} = (xmax -xmin) \\cdot (ymax - ymin)\\] \\[iou =  {area_{inside}\\over area_{bbox} + area_{total} - area_{inside}}\\]"},{"location":"tests/#scenario-1-simple-square","title":"Scenario 1: Simple Square","text":"<p>The three example masks with given bbox are defined as the following:</p> <ul> <li>total image size: 5 x 5</li> </ul> Pixels T-shape Pixels Cross Pixels Rects \\(count_{total}\\) \\(9\\) \\(5\\) \\(7\\) \\(count_{inside}\\) \\(3\\) \\(5\\) \\(4\\) \\(iou\\) \\({3\\over15}\\) \\({5\\over9}\\) \\({4\\over12}\\) bbox \\(xmin\\) \\(1\\) \\(ymin\\) \\(1\\) \\(xmax\\) \\(4\\) \\(ymax\\) \\(4\\) \\(area\\_{bbox}\\) \\(9\\)"},{"location":"tests/#scenario-2-rectangle-unequal-ratio","title":"Scenario 2: Rectangle unequal ratio","text":"<p>The three example masks with given bbox are defined as the following:</p> <ul> <li>total image size: 5 x 6</li> </ul> Pixels T-shape Pixels Cross Pixels Rects \\(count_{total}\\) \\(10\\) \\(6\\) \\(9\\) \\(count_{inside}\\) \\(4\\) \\(6\\) \\(6\\) \\(iou\\) \\({4\\over18}\\) \\({6\\over12}\\) \\({6\\over15}\\) bbox \\(xmin\\) \\(1\\) \\(ymin\\) \\(1\\) \\(xmax\\) \\(4\\) \\(ymax\\) \\(5\\) \\(area_{bbox}\\) \\(12\\)"},{"location":"tests/#scenario-3-invalid-single-point-invalid-size","title":"Scenario 3: invalid single point, invalid size","text":"<p>A single Pixel.</p> <p>Variable <code>indices</code> is valid, but the size of image is 2D.</p> <p>Should raise a SizeValueError.</p>"},{"location":"tests/#scenario-4-valid-single-point-valid-size","title":"Scenario 4: valid single point, valid size","text":"<p>A single Pixel.</p> <p>Variables <code>indices</code> is invalid (two axis), size of image is 3D.</p>"},{"location":"tests/#scenario-5-mask-outside","title":"Scenario 5: Mask Outside","text":"<p>The two example masks with given bbox are defined as the following:</p> <ul> <li>total image size: 5 x 5</li> </ul> Pixels Cross Pixels L-Shape \\(count_{total}\\) \\(5\\) \\(5\\) \\(count_{inside}\\) \\(5\\) \\(0\\) \\(iou\\) \\({5\\over9}\\) \\({0\\over14}\\) bbox \\(xmin\\) \\(1\\) \\(ymin\\) \\(1\\) \\(xmax\\) \\(4\\) \\(ymax\\) \\(4\\) \\(area\\_{bbox}\\) \\(9\\) <p>The test should show that, even so the calculation for the second example provides zero iou the value is also created.</p>"},{"location":"tests/#scenario-6-empty-mask","title":"Scenario 6: Empty Mask","text":"<p>Same Masks as in Scenario 5 but this time an empty mask is placed between them. This is done by moving the L-Shape on N layer with index = 2.</p> <ul> <li>total image size: 5 x 5</li> </ul> Pixels Cross Empty Mask Pixels L-Shape \\(count_{total}\\) \\(5\\) \\(0\\) \\(5\\) \\(count_{inside}\\) \\(5\\) \\(0\\) \\(0\\) \\(iou\\) \\({5\\over9}\\) \\(0\\) \\({0\\over14}\\) bbox \\(xmin\\) \\(1\\) \\(ymin\\) \\(1\\) \\(xmax\\) \\(4\\) \\(ymax\\) \\(4\\) \\(area\\_{bbox}\\) \\(9\\)"}]}